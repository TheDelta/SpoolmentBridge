/**
 * Spoolman REST API v1
 *      REST API for Spoolman.      The API is served on the path `/api/v1/`.      Some endpoints also serve a websocket on the same path. The websocket is used to listen for changes to the data     that the endpoint serves. The websocket messages are JSON objects. Additionally, there is a root-level websocket     endpoint that listens for changes to any data in the database.     
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { EntityTypeDto } from '../model/entityType.dto';
import { ExtraFieldDto } from '../model/extraField.dto';
import { ExtraFieldParametersDto } from '../model/extraFieldParameters.dto';
import { HTTPValidationErrorDto } from '../model/hTTPValidationError.dto';
import { MessageDto } from '../model/message.dto';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';

/**
 * Request parameters for addOrUpdateExtraFieldFieldEntityTypeKeyPost operation in FieldApi.
 * @export
 * @interface FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPostRequest
 */
export interface FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPostRequest {
    /**
     * Entity type this field is for
     * @type {EntityTypeDto}
     * @memberof FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPost
     */
    readonly 'entity_type': EntityTypeDto

    /**
     * 
     * @type {string}
     * @memberof FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ExtraFieldParametersDto}
     * @memberof FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPost
     */
    readonly 'ExtraFieldParametersDto': ExtraFieldParametersDto
}

/**
 * Request parameters for deleteExtraFieldFieldEntityTypeKeyDelete operation in FieldApi.
 * @export
 * @interface FieldApiDeleteExtraFieldFieldEntityTypeKeyDeleteRequest
 */
export interface FieldApiDeleteExtraFieldFieldEntityTypeKeyDeleteRequest {
    /**
     * Entity type this field is for
     * @type {EntityTypeDto}
     * @memberof FieldApiDeleteExtraFieldFieldEntityTypeKeyDelete
     */
    readonly 'entity_type': EntityTypeDto

    /**
     * 
     * @type {string}
     * @memberof FieldApiDeleteExtraFieldFieldEntityTypeKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for getExtraFieldsFieldEntityTypeGet operation in FieldApi.
 * @export
 * @interface FieldApiGetExtraFieldsFieldEntityTypeGetRequest
 */
export interface FieldApiGetExtraFieldsFieldEntityTypeGetRequest {
    /**
     * Entity type this field is for
     * @type {EntityTypeDto}
     * @memberof FieldApiGetExtraFieldsFieldEntityTypeGet
     */
    readonly 'entity_type': EntityTypeDto
}


@Injectable()
export class FieldApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Add Or Update Extra Field
     * Add or update an extra field for a specific entity type. Returns the full list of extra fields for the entity type.
     * @param {FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [addOrUpdateExtraFieldFieldEntityTypeKeyPostOpts.config] Override http request option.
     */
    public addOrUpdateExtraFieldFieldEntityTypeKeyPost(requestParameters: FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPostRequest, addOrUpdateExtraFieldFieldEntityTypeKeyPostOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Array<ExtraFieldDto>>>;
    public addOrUpdateExtraFieldFieldEntityTypeKeyPost(requestParameters: FieldApiAddOrUpdateExtraFieldFieldEntityTypeKeyPostRequest, addOrUpdateExtraFieldFieldEntityTypeKeyPostOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'entity_type': entityType,
            key,
            'ExtraFieldParametersDto': extraFieldParametersDto,
        } = requestParameters;

        if (entityType === null || entityType === undefined) {
            throw new Error('Required parameter entityType was null or undefined when calling addOrUpdateExtraFieldFieldEntityTypeKeyPost.');
        }

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling addOrUpdateExtraFieldFieldEntityTypeKeyPost.');
        }

        if (extraFieldParametersDto === null || extraFieldParametersDto === undefined) {
            throw new Error('Required parameter extraFieldParametersDto was null or undefined when calling addOrUpdateExtraFieldFieldEntityTypeKeyPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Array<ExtraFieldDto>>(`${this.basePath}/field/${encodeURIComponent(String(entityType))}/${encodeURIComponent(String(key))}`,
                    extraFieldParametersDto,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...addOrUpdateExtraFieldFieldEntityTypeKeyPostOpts?.config,
                        headers: {...headers, ...addOrUpdateExtraFieldFieldEntityTypeKeyPostOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete Extra Field
     * Delete an extra field for a specific entity type. Returns the full list of extra fields for the entity type.
     * @param {FieldApiDeleteExtraFieldFieldEntityTypeKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [deleteExtraFieldFieldEntityTypeKeyDeleteOpts.config] Override http request option.
     */
    public deleteExtraFieldFieldEntityTypeKeyDelete(requestParameters: FieldApiDeleteExtraFieldFieldEntityTypeKeyDeleteRequest, deleteExtraFieldFieldEntityTypeKeyDeleteOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Array<ExtraFieldDto>>>;
    public deleteExtraFieldFieldEntityTypeKeyDelete(requestParameters: FieldApiDeleteExtraFieldFieldEntityTypeKeyDeleteRequest, deleteExtraFieldFieldEntityTypeKeyDeleteOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'entity_type': entityType,
            key,
        } = requestParameters;

        if (entityType === null || entityType === undefined) {
            throw new Error('Required parameter entityType was null or undefined when calling deleteExtraFieldFieldEntityTypeKeyDelete.');
        }

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteExtraFieldFieldEntityTypeKeyDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<Array<ExtraFieldDto>>(`${this.basePath}/field/${encodeURIComponent(String(entityType))}/${encodeURIComponent(String(key))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteExtraFieldFieldEntityTypeKeyDeleteOpts?.config,
                        headers: {...headers, ...deleteExtraFieldFieldEntityTypeKeyDeleteOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get Extra Fields
     * Get all extra fields for a specific entity type.
     * @param {FieldApiGetExtraFieldsFieldEntityTypeGetRequest} requestParameters Request parameters.
     * @param {*} [getExtraFieldsFieldEntityTypeGetOpts.config] Override http request option.
     */
    public getExtraFieldsFieldEntityTypeGet(requestParameters: FieldApiGetExtraFieldsFieldEntityTypeGetRequest, getExtraFieldsFieldEntityTypeGetOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Array<ExtraFieldDto>>>;
    public getExtraFieldsFieldEntityTypeGet(requestParameters: FieldApiGetExtraFieldsFieldEntityTypeGetRequest, getExtraFieldsFieldEntityTypeGetOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'entity_type': entityType,
        } = requestParameters;

        if (entityType === null || entityType === undefined) {
            throw new Error('Required parameter entityType was null or undefined when calling getExtraFieldsFieldEntityTypeGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<ExtraFieldDto>>(`${this.basePath}/field/${encodeURIComponent(String(entityType))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getExtraFieldsFieldEntityTypeGetOpts?.config,
                        headers: {...headers, ...getExtraFieldsFieldEntityTypeGetOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
