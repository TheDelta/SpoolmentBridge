/**
 * Spoolman REST API v1
 *      REST API for Spoolman.      The API is served on the path `/api/v1/`.      Some endpoints also serve a websocket on the same path. The websocket is used to listen for changes to the data     that the endpoint serves. The websocket messages are JSON objects. Additionally, there is a root-level websocket     endpoint that listens for changes to any data in the database.     
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { HTTPValidationErrorDto } from '../model/hTTPValidationError.dto';
import { MessageDto } from '../model/message.dto';
import { VendorDto } from '../model/vendor.dto';
import { VendorEventDto } from '../model/vendorEvent.dto';
import { VendorParametersDto } from '../model/vendorParameters.dto';
import { VendorUpdateParametersDto } from '../model/vendorUpdateParameters.dto';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';

/**
 * Request parameters for addVendorVendorPost operation in VendorApi.
 * @export
 * @interface VendorApiAddVendorVendorPostRequest
 */
export interface VendorApiAddVendorVendorPostRequest {
    /**
     * 
     * @type {VendorParametersDto}
     * @memberof VendorApiAddVendorVendorPost
     */
    readonly 'VendorParametersDto': VendorParametersDto
}

/**
 * Request parameters for deleteVendorVendorVendorIdDelete operation in VendorApi.
 * @export
 * @interface VendorApiDeleteVendorVendorVendorIdDeleteRequest
 */
export interface VendorApiDeleteVendorVendorVendorIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof VendorApiDeleteVendorVendorVendorIdDelete
     */
    readonly 'vendor_id': number
}

/**
 * Request parameters for findVendorVendorGet operation in VendorApi.
 * @export
 * @interface VendorApiFindVendorVendorGetRequest
 */
export interface VendorApiFindVendorVendorGetRequest {
    /**
     * Partial case-insensitive search term for the vendor name. Separate multiple terms with a comma. Surround a term with quotes to search for the exact term.
     * @type {string}
     * @memberof VendorApiFindVendorVendorGet
     */
    readonly name?: string

    /**
     * Exact match for the vendor external ID. Separate multiple IDs with a comma. Specify empty string to match filaments with no external ID. Surround a term with quotes to search for the exact term.
     * @type {string}
     * @memberof VendorApiFindVendorVendorGet
     */
    readonly 'external_id'?: string

    /**
     * Sort the results by the given field. Should be a comma-separate string with \&quot;field:direction\&quot; items.
     * @type {string}
     * @memberof VendorApiFindVendorVendorGet
     */
    readonly sort?: string

    /**
     * Maximum number of items in the response.
     * @type {number}
     * @memberof VendorApiFindVendorVendorGet
     */
    readonly limit?: number

    /**
     * Offset in the full result set if a limit is set.
     * @type {number}
     * @memberof VendorApiFindVendorVendorGet
     */
    readonly offset?: number
}

/**
 * Request parameters for getVendorVendorVendorIdGet operation in VendorApi.
 * @export
 * @interface VendorApiGetVendorVendorVendorIdGetRequest
 */
export interface VendorApiGetVendorVendorVendorIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof VendorApiGetVendorVendorVendorIdGet
     */
    readonly 'vendor_id': number
}

/**
 * Request parameters for updateVendorVendorVendorIdPatch operation in VendorApi.
 * @export
 * @interface VendorApiUpdateVendorVendorVendorIdPatchRequest
 */
export interface VendorApiUpdateVendorVendorVendorIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof VendorApiUpdateVendorVendorVendorIdPatch
     */
    readonly 'vendor_id': number

    /**
     * 
     * @type {VendorUpdateParametersDto}
     * @memberof VendorApiUpdateVendorVendorVendorIdPatch
     */
    readonly 'VendorUpdateParametersDto': VendorUpdateParametersDto
}


@Injectable()
export class VendorApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Add Vendor
     * Add a new vendor to the database.
     * @param {VendorApiAddVendorVendorPostRequest} requestParameters Request parameters.
     * @param {*} [addVendorVendorPostOpts.config] Override http request option.
     */
    public addVendorVendorPost(requestParameters: VendorApiAddVendorVendorPostRequest, addVendorVendorPostOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<VendorDto>>;
    public addVendorVendorPost(requestParameters: VendorApiAddVendorVendorPostRequest, addVendorVendorPostOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'VendorParametersDto': vendorParametersDto,
        } = requestParameters;

        if (vendorParametersDto === null || vendorParametersDto === undefined) {
            throw new Error('Required parameter vendorParametersDto was null or undefined when calling addVendorVendorPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<VendorDto>(`${this.basePath}/vendor`,
                    vendorParametersDto,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...addVendorVendorPostOpts?.config,
                        headers: {...headers, ...addVendorVendorPostOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete Vendor
     * Delete a vendor. The vendor attribute of any filaments who refer to the deleted vendor will be cleared.
     * @param {VendorApiDeleteVendorVendorVendorIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [deleteVendorVendorVendorIdDeleteOpts.config] Override http request option.
     */
    public deleteVendorVendorVendorIdDelete(requestParameters: VendorApiDeleteVendorVendorVendorIdDeleteRequest, deleteVendorVendorVendorIdDeleteOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MessageDto>>;
    public deleteVendorVendorVendorIdDelete(requestParameters: VendorApiDeleteVendorVendorVendorIdDeleteRequest, deleteVendorVendorVendorIdDeleteOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'vendor_id': vendorId,
        } = requestParameters;

        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling deleteVendorVendorVendorIdDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<MessageDto>(`${this.basePath}/vendor/${encodeURIComponent(String(vendorId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteVendorVendorVendorIdDeleteOpts?.config,
                        headers: {...headers, ...deleteVendorVendorVendorIdDeleteOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Find Vendor
     * Get a list of vendors that matches the search query. A websocket is served on the same path to listen for updates to any vendor, or added or deleted vendors. See the HTTP Response code 299 for the content of the websocket messages.
     * @param {VendorApiFindVendorVendorGetRequest} requestParameters Request parameters.
     * @param {*} [findVendorVendorGetOpts.config] Override http request option.
     */
    public findVendorVendorGet(requestParameters: VendorApiFindVendorVendorGetRequest, findVendorVendorGetOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Array<VendorDto>>>;
    public findVendorVendorGet(requestParameters: VendorApiFindVendorVendorGetRequest, findVendorVendorGetOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            name,
            'external_id': externalId,
            sort,
            limit,
            offset,
        } = requestParameters;

        let queryParameters = new URLSearchParams();
        if (name !== undefined && name !== null) {
            queryParameters.append('name', <any>name);
        }
        if (externalId !== undefined && externalId !== null) {
            queryParameters.append('external_id', <any>externalId);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters.append('offset', <any>offset);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<VendorDto>>(`${this.basePath}/vendor`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...findVendorVendorGetOpts?.config,
                        headers: {...headers, ...findVendorVendorGetOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get Vendor
     * Get a specific vendor. A websocket is served on the same path to listen for changes to the vendor. See the HTTP Response code 299 for the content of the websocket messages.
     * @param {VendorApiGetVendorVendorVendorIdGetRequest} requestParameters Request parameters.
     * @param {*} [getVendorVendorVendorIdGetOpts.config] Override http request option.
     */
    public getVendorVendorVendorIdGet(requestParameters: VendorApiGetVendorVendorVendorIdGetRequest, getVendorVendorVendorIdGetOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<VendorDto>>;
    public getVendorVendorVendorIdGet(requestParameters: VendorApiGetVendorVendorVendorIdGetRequest, getVendorVendorVendorIdGetOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'vendor_id': vendorId,
        } = requestParameters;

        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling getVendorVendorVendorIdGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<VendorDto>(`${this.basePath}/vendor/${encodeURIComponent(String(vendorId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getVendorVendorVendorIdGetOpts?.config,
                        headers: {...headers, ...getVendorVendorVendorIdGetOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update Vendor
     * Update any attribute of a vendor. Only fields specified in the request will be affected. If extra is set, all existing extra fields will be removed and replaced with the new ones.
     * @param {VendorApiUpdateVendorVendorVendorIdPatchRequest} requestParameters Request parameters.
     * @param {*} [updateVendorVendorVendorIdPatchOpts.config] Override http request option.
     */
    public updateVendorVendorVendorIdPatch(requestParameters: VendorApiUpdateVendorVendorVendorIdPatchRequest, updateVendorVendorVendorIdPatchOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<VendorDto>>;
    public updateVendorVendorVendorIdPatch(requestParameters: VendorApiUpdateVendorVendorVendorIdPatchRequest, updateVendorVendorVendorIdPatchOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'vendor_id': vendorId,
            'VendorUpdateParametersDto': vendorUpdateParametersDto,
        } = requestParameters;

        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling updateVendorVendorVendorIdPatch.');
        }

        if (vendorUpdateParametersDto === null || vendorUpdateParametersDto === undefined) {
            throw new Error('Required parameter vendorUpdateParametersDto was null or undefined when calling updateVendorVendorVendorIdPatch.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<VendorDto>(`${this.basePath}/vendor/${encodeURIComponent(String(vendorId))}`,
                    vendorUpdateParametersDto,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...updateVendorVendorVendorIdPatchOpts?.config,
                        headers: {...headers, ...updateVendorVendorVendorIdPatchOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
