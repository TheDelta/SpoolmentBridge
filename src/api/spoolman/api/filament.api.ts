/**
 * Spoolman REST API v1
 *      REST API for Spoolman.      The API is served on the path `/api/v1/`.      Some endpoints also serve a websocket on the same path. The websocket is used to listen for changes to the data     that the endpoint serves. The websocket messages are JSON objects. Additionally, there is a root-level websocket     endpoint that listens for changes to any data in the database.     
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { FilamentDto } from '../model/filament.dto';
import { FilamentEventDto } from '../model/filamentEvent.dto';
import { FilamentParametersDto } from '../model/filamentParameters.dto';
import { FilamentUpdateParametersDto } from '../model/filamentUpdateParameters.dto';
import { HTTPValidationErrorDto } from '../model/hTTPValidationError.dto';
import { MessageDto } from '../model/message.dto';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';

/**
 * Request parameters for addFilamentFilamentPost operation in FilamentApi.
 * @export
 * @interface FilamentApiAddFilamentFilamentPostRequest
 */
export interface FilamentApiAddFilamentFilamentPostRequest {
    /**
     * 
     * @type {FilamentParametersDto}
     * @memberof FilamentApiAddFilamentFilamentPost
     */
    readonly 'FilamentParametersDto': FilamentParametersDto
}

/**
 * Request parameters for deleteFilamentFilamentFilamentIdDelete operation in FilamentApi.
 * @export
 * @interface FilamentApiDeleteFilamentFilamentFilamentIdDeleteRequest
 */
export interface FilamentApiDeleteFilamentFilamentFilamentIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof FilamentApiDeleteFilamentFilamentFilamentIdDelete
     */
    readonly 'filament_id': number
}

/**
 * Request parameters for findFilamentsFilamentGet operation in FilamentApi.
 * @export
 * @interface FilamentApiFindFilamentsFilamentGetRequest
 */
export interface FilamentApiFindFilamentsFilamentGetRequest {
    /**
     * See vendor.name.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'vendor_name'?: string

    /**
     * See vendor.id.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'vendor_id'?: string

    /**
     * Partial case-insensitive search term for the filament vendor name. Separate multiple terms with a comma. Specify an empty string to match filaments with no vendor name. Surround a term with quotes to search for the exact term.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'vendor.name'?: string

    /**
     * Match an exact vendor ID. Separate multiple IDs with a comma. Specify -1 to match filaments with no vendor.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'vendor.id'?: string

    /**
     * Partial case-insensitive search term for the filament name. Separate multiple terms with a comma. Specify an empty string to match filaments with no name. Surround a term with quotes to search for the exact term.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly name?: string

    /**
     * Partial case-insensitive search term for the filament material. Separate multiple terms with a comma. Specify an empty string to match filaments with no material. Surround a term with quotes to search for the exact term.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly material?: string

    /**
     * Partial case-insensitive search term for the filament article number. Separate multiple terms with a comma. Specify an empty string to match filaments with no article number. Surround a term with quotes to search for the exact term.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'article_number'?: string

    /**
     * Match filament by similar color. Slow operation!
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'color_hex'?: string

    /**
     * The similarity threshold for color matching. A value between 0.0-100.0, where 0 means match only exactly the same color.
     * @type {number}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'color_similarity_threshold'?: number

    /**
     * Find filaments imported by the given external ID. Separate multiple IDs with a comma. Specify empty string to match filaments with no external ID. Surround a term with quotes to search for the exact term.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly 'external_id'?: string

    /**
     * Sort the results by the given field. Should be a comma-separate string with \&quot;field:direction\&quot; items.
     * @type {string}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly sort?: string

    /**
     * Maximum number of items in the response.
     * @type {number}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly limit?: number

    /**
     * Offset in the full result set if a limit is set.
     * @type {number}
     * @memberof FilamentApiFindFilamentsFilamentGet
     */
    readonly offset?: number
}

/**
 * Request parameters for getFilamentFilamentFilamentIdGet operation in FilamentApi.
 * @export
 * @interface FilamentApiGetFilamentFilamentFilamentIdGetRequest
 */
export interface FilamentApiGetFilamentFilamentFilamentIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof FilamentApiGetFilamentFilamentFilamentIdGet
     */
    readonly 'filament_id': number
}

/**
 * Request parameters for updateFilamentFilamentFilamentIdPatch operation in FilamentApi.
 * @export
 * @interface FilamentApiUpdateFilamentFilamentFilamentIdPatchRequest
 */
export interface FilamentApiUpdateFilamentFilamentFilamentIdPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof FilamentApiUpdateFilamentFilamentFilamentIdPatch
     */
    readonly 'filament_id': number

    /**
     * 
     * @type {FilamentUpdateParametersDto}
     * @memberof FilamentApiUpdateFilamentFilamentFilamentIdPatch
     */
    readonly 'FilamentUpdateParametersDto': FilamentUpdateParametersDto
}


@Injectable()
export class FilamentApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Add Filament
     * Add a new filament to the database.
     * @param {FilamentApiAddFilamentFilamentPostRequest} requestParameters Request parameters.
     * @param {*} [addFilamentFilamentPostOpts.config] Override http request option.
     */
    public addFilamentFilamentPost(requestParameters: FilamentApiAddFilamentFilamentPostRequest, addFilamentFilamentPostOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<FilamentDto>>;
    public addFilamentFilamentPost(requestParameters: FilamentApiAddFilamentFilamentPostRequest, addFilamentFilamentPostOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'FilamentParametersDto': filamentParametersDto,
        } = requestParameters;

        if (filamentParametersDto === null || filamentParametersDto === undefined) {
            throw new Error('Required parameter filamentParametersDto was null or undefined when calling addFilamentFilamentPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<FilamentDto>(`${this.basePath}/filament`,
                    filamentParametersDto,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...addFilamentFilamentPostOpts?.config,
                        headers: {...headers, ...addFilamentFilamentPostOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete Filament
     * Delete a filament.
     * @param {FilamentApiDeleteFilamentFilamentFilamentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [deleteFilamentFilamentFilamentIdDeleteOpts.config] Override http request option.
     */
    public deleteFilamentFilamentFilamentIdDelete(requestParameters: FilamentApiDeleteFilamentFilamentFilamentIdDeleteRequest, deleteFilamentFilamentFilamentIdDeleteOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MessageDto>>;
    public deleteFilamentFilamentFilamentIdDelete(requestParameters: FilamentApiDeleteFilamentFilamentFilamentIdDeleteRequest, deleteFilamentFilamentFilamentIdDeleteOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'filament_id': filamentId,
        } = requestParameters;

        if (filamentId === null || filamentId === undefined) {
            throw new Error('Required parameter filamentId was null or undefined when calling deleteFilamentFilamentFilamentIdDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<MessageDto>(`${this.basePath}/filament/${encodeURIComponent(String(filamentId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteFilamentFilamentFilamentIdDeleteOpts?.config,
                        headers: {...headers, ...deleteFilamentFilamentFilamentIdDeleteOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Find Filaments
     * Get a list of filaments that matches the search query. A websocket is served on the same path to listen for updates to any filament, or added or deleted filaments. See the HTTP Response code 299 for the content of the websocket messages.
     * @param {FilamentApiFindFilamentsFilamentGetRequest} requestParameters Request parameters.
     * @param {*} [findFilamentsFilamentGetOpts.config] Override http request option.
     */
    public findFilamentsFilamentGet(requestParameters: FilamentApiFindFilamentsFilamentGetRequest, findFilamentsFilamentGetOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Array<FilamentDto>>>;
    public findFilamentsFilamentGet(requestParameters: FilamentApiFindFilamentsFilamentGetRequest, findFilamentsFilamentGetOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'vendor_name': vendorName,
            'vendor_id': vendorId,
            'vendor.name': vendorName2,
            'vendor.id': vendorId2,
            name,
            material,
            'article_number': articleNumber,
            'color_hex': colorHex,
            'color_similarity_threshold': colorSimilarityThreshold,
            'external_id': externalId,
            sort,
            limit,
            offset,
        } = requestParameters;

        let queryParameters = new URLSearchParams();
        if (vendorName !== undefined && vendorName !== null) {
            queryParameters.append('vendor_name', <any>vendorName);
        }
        if (vendorId !== undefined && vendorId !== null) {
            queryParameters.append('vendor_id', <any>vendorId);
        }
        if (vendorName2 !== undefined && vendorName2 !== null) {
            queryParameters.append('vendor.name', <any>vendorName2);
        }
        if (vendorId2 !== undefined && vendorId2 !== null) {
            queryParameters.append('vendor.id', <any>vendorId2);
        }
        if (name !== undefined && name !== null) {
            queryParameters.append('name', <any>name);
        }
        if (material !== undefined && material !== null) {
            queryParameters.append('material', <any>material);
        }
        if (articleNumber !== undefined && articleNumber !== null) {
            queryParameters.append('article_number', <any>articleNumber);
        }
        if (colorHex !== undefined && colorHex !== null) {
            queryParameters.append('color_hex', <any>colorHex);
        }
        if (colorSimilarityThreshold !== undefined && colorSimilarityThreshold !== null) {
            queryParameters.append('color_similarity_threshold', <any>colorSimilarityThreshold);
        }
        if (externalId !== undefined && externalId !== null) {
            queryParameters.append('external_id', <any>externalId);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters.append('offset', <any>offset);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<FilamentDto>>(`${this.basePath}/filament`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...findFilamentsFilamentGetOpts?.config,
                        headers: {...headers, ...findFilamentsFilamentGetOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get Filament
     * Get a specific filament. A websocket is served on the same path to listen for changes to the filament. See the HTTP Response code 299 for the content of the websocket messages.
     * @param {FilamentApiGetFilamentFilamentFilamentIdGetRequest} requestParameters Request parameters.
     * @param {*} [getFilamentFilamentFilamentIdGetOpts.config] Override http request option.
     */
    public getFilamentFilamentFilamentIdGet(requestParameters: FilamentApiGetFilamentFilamentFilamentIdGetRequest, getFilamentFilamentFilamentIdGetOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<FilamentDto>>;
    public getFilamentFilamentFilamentIdGet(requestParameters: FilamentApiGetFilamentFilamentFilamentIdGetRequest, getFilamentFilamentFilamentIdGetOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'filament_id': filamentId,
        } = requestParameters;

        if (filamentId === null || filamentId === undefined) {
            throw new Error('Required parameter filamentId was null or undefined when calling getFilamentFilamentFilamentIdGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<FilamentDto>(`${this.basePath}/filament/${encodeURIComponent(String(filamentId))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getFilamentFilamentFilamentIdGetOpts?.config,
                        headers: {...headers, ...getFilamentFilamentFilamentIdGetOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update Filament
     * Update any attribute of a filament. Only fields specified in the request will be affected. If extra is set, all existing extra fields will be removed and replaced with the new ones.
     * @param {FilamentApiUpdateFilamentFilamentFilamentIdPatchRequest} requestParameters Request parameters.
     * @param {*} [updateFilamentFilamentFilamentIdPatchOpts.config] Override http request option.
     */
    public updateFilamentFilamentFilamentIdPatch(requestParameters: FilamentApiUpdateFilamentFilamentFilamentIdPatchRequest, updateFilamentFilamentFilamentIdPatchOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<FilamentDto>>;
    public updateFilamentFilamentFilamentIdPatch(requestParameters: FilamentApiUpdateFilamentFilamentFilamentIdPatchRequest, updateFilamentFilamentFilamentIdPatchOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            'filament_id': filamentId,
            'FilamentUpdateParametersDto': filamentUpdateParametersDto,
        } = requestParameters;

        if (filamentId === null || filamentId === undefined) {
            throw new Error('Required parameter filamentId was null or undefined when calling updateFilamentFilamentFilamentIdPatch.');
        }

        if (filamentUpdateParametersDto === null || filamentUpdateParametersDto === undefined) {
            throw new Error('Required parameter filamentUpdateParametersDto was null or undefined when calling updateFilamentFilamentFilamentIdPatch.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<FilamentDto>(`${this.basePath}/filament/${encodeURIComponent(String(filamentId))}`,
                    filamentUpdateParametersDto,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...updateFilamentFilamentFilamentIdPatchOpts?.config,
                        headers: {...headers, ...updateFilamentFilamentFilamentIdPatchOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
