/**
 * Spoolman REST API v1
 *      REST API for Spoolman.      The API is served on the path `/api/v1/`.      Some endpoints also serve a websocket on the same path. The websocket is used to listen for changes to the data     that the endpoint serves. The websocket messages are JSON objects. Additionally, there is a root-level websocket     endpoint that listens for changes to any data in the database.     
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { HTTPValidationErrorDto } from '../model/hTTPValidationError.dto';
import { MessageDto } from '../model/message.dto';
import { SettingEventDto } from '../model/settingEvent.dto';
import { SettingResponseDto } from '../model/settingResponse.dto';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';

/**
 * Request parameters for getSettingSettingKeyGet operation in SettingApi.
 * @export
 * @interface SettingApiGetSettingSettingKeyGetRequest
 */
export interface SettingApiGetSettingSettingKeyGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SettingApiGetSettingSettingKeyGet
     */
    readonly key: string
}

/**
 * Request parameters for setSettingSettingKeyPost operation in SettingApi.
 * @export
 * @interface SettingApiSetSettingSettingKeyPostRequest
 */
export interface SettingApiSetSettingSettingKeyPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SettingApiSetSettingSettingKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {string}
     * @memberof SettingApiSetSettingSettingKeyPost
     */
    readonly body: string
}


@Injectable()
export class SettingApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Get All Settings
     * Get all settings, set or not. If the setting has not been set, \&#39;value\&#39; will be the default value.
     * @param {*} [getAllSettingsSettingGetOpts.config] Override http request option.
     */
    public getAllSettingsSettingGet(getAllSettingsSettingGetOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<{ [key: string]: SettingResponseDto; }>>;
    public getAllSettingsSettingGet(getAllSettingsSettingGetOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<{ [key: string]: SettingResponseDto; }>(`${this.basePath}/setting/`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getAllSettingsSettingGetOpts?.config,
                        headers: {...headers, ...getAllSettingsSettingGetOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get Setting
     * Get a specific setting. If the setting has not been set, the default value will be returned.A websocket is served on the same path to listen for changes to the setting. See the HTTP Response code 299 for the content of the websocket messages.
     * @param {SettingApiGetSettingSettingKeyGetRequest} requestParameters Request parameters.
     * @param {*} [getSettingSettingKeyGetOpts.config] Override http request option.
     */
    public getSettingSettingKeyGet(requestParameters: SettingApiGetSettingSettingKeyGetRequest, getSettingSettingKeyGetOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<SettingResponseDto>>;
    public getSettingSettingKeyGet(requestParameters: SettingApiGetSettingSettingKeyGetRequest, getSettingSettingKeyGetOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            key,
        } = requestParameters;

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling getSettingSettingKeyGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<SettingResponseDto>(`${this.basePath}/setting/${encodeURIComponent(String(key))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getSettingSettingKeyGetOpts?.config,
                        headers: {...headers, ...getSettingSettingKeyGetOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Set Setting
     * Set the value of a setting. The body must match the JSON type of the setting. An empty body or a body containing only \&#39;null\&#39; will reset the setting to its default value. The new value will be returned.
     * @param {SettingApiSetSettingSettingKeyPostRequest} requestParameters Request parameters.
     * @param {*} [setSettingSettingKeyPostOpts.config] Override http request option.
     */
    public setSettingSettingKeyPost(requestParameters: SettingApiSetSettingSettingKeyPostRequest, setSettingSettingKeyPostOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<SettingResponseDto>>;
    public setSettingSettingKeyPost(requestParameters: SettingApiSetSettingSettingKeyPostRequest, setSettingSettingKeyPostOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        const {
            key,
            body,
        } = requestParameters;

        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling setSettingSettingKeyPost.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setSettingSettingKeyPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<SettingResponseDto>(`${this.basePath}/setting/${encodeURIComponent(String(key))}`,
                    body,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...setSettingSettingKeyPostOpts?.config,
                        headers: {...headers, ...setSettingSettingKeyPostOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
